## 字符串

 - [最长公共前缀](https://github.com/hytStart/daybydayStudy/issues/10)
 - [最长回文串](https://github.com/hytStart/daybydayStudy/issues/13)
 - [最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/) // todo 动态规划
 - [翻转字符串里的单词](https://github.com/hytStart/daybydayStudy/issues/15)
 - [实现 strStr()](https://github.com/hytStart/daybydayStudy/issues/16)


 ## 双指针技巧 1

 1. [反转字符串](https://leetcode-cn.com/problems/reverse-string/)

 其思想是分别将两个指针分别指向数组的开头及末尾，然后将其指向的元素进行交换，再将指针向中间移动一步，继续交换，直到这两个指针相遇。

```
 /**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    let left = 0, right = s.length -1
    while (left < right) {
        [s[left], s[right]] = [s[right], s[left]]
        // let temp = s[left]
        // s[left] = s[right]
        // s[right]= temp
        left++
        right--
    }
    return s
};
```

2. [反转字符串进阶版](https://leetcode-cn.com/problems/reverse-string-ii/)

理解题意：反转每个下标从 2k 的倍数开始的，长度为 k 的子串。若该子串长度不足 k，则反转整个子串。

每次前进2k步

```
/**
 * @param {string} s
 * @param {number} k
 * @return {string}
 */
var reverseStr = function(s, k) {
    let n = s.length
    let arr = s.split('')
    for (let i = 0; i < n; i += 2 * k) {
        rev(arr, i, Math.min(i + k, n) -1)
    }
    return arr.join('')
};

var rev = function(s, left ,right) {
    while (left < right) {
        [s[left], s[right]] = [s[right], s[left]]
        left++
        right--
    }
    return s
};
```

3. [数组拆分 I](https://leetcode-cn.com/problems/array-partition-i/)

a1作为全局最小值，无论跟谁一组a1都会被累加进答案，相反，a1的搭档会被永久排除。  
既然如此，莫不如排除一个较小的数，即给a1找一个“最小的搭档”b1。

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var arrayPairSum = function(nums) {
    nums = nums.sort((a, b) => a - b)
    let res = 0
    for(let i = 0; i < nums.length; i += 2) {
        res += nums[i]
    }
    return res
};
```

4. [两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

hash存储

```
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    const m = {}
    for(let i = 0; i < numbers.length; i++) {
        const diff = target - numbers[i]
        if (m[diff] != null) {
            return [m[diff] + 1, i + 1]
        } else {
            m[numbers[i]] = i
        }
    }
};
```

双指针

注意，left++时，重置right

```
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    let left = 0, right = numbers.length - 1
    while (left < right) {
        if (numbers[left] + numbers[right] < target) {
            left++
        } else if (numbers[left] + numbers[right] > target) {
            right--
        } else {
            return [left + 1, right + 1]
        }
    }
};
```

固定一个数，之后采用二分法查找

```
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    for (let i = 0; i < numbers.length; i++) {
        let o = numbers[i]
        let left = i + 1
        let right = numbers.length - 1
        while (left <= right) {
            let mid = Math.floor((left + right) / 2)
            // let mid = Math.floor((right - left) / 2) + left
            if (o + numbers[mid] < target) {
                left = mid + 1
            } else if (o + numbers[mid] > target) {
                right = mid -1
            } else {
                return [i +1, mid + 1]
            }
        }
    }
};
```

## 双指针技巧 2

有时，我们可以使用两个不同步的指针来解决问题，即快慢指针。与情景一不同的是，两个指针的运动方向是相同的，而非相反。

1. [移除元素](https://leetcode-cn.com/problems/remove-element/)

采用快慢指针的思想：初始化一个快指针 fast 和一个慢指针 slow，fast 每次移动一步，而 slow 只当 fast 指向的值不等于 val 时才移动一步。

```
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let slow = 0
    for (let fast = 0; fast < nums.length; fast++) {
        if (nums[fast] !== val) {
            nums[slow] = nums[fast]
            slow++
        }
    }
    return slow
};
```

双指针优化，避免了需要保留的元素的重复赋值操作。

如果要移除的元素恰好在数组的开头，例如序列 [1,2,3,4,5]，当 val 为 1 时，我们需要把每一个元素都左移一位。注意到题目中说：「元素的顺序可以改变」。实际上我们可以直接将最后一个元素 5 移动到序列开头，取代元素 1，得到序列 [5,2,3,4]，同样满足题目要求。这个优化在序列中 val 元素的数量较少时非常有效。


```
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    let left = 0, right = nums.length - 1
    while (left <= right) {
        if (nums[left] == val) {
            nums[left] = nums[right]
            right--
        } else {
            left++
        }
    }
    return left
};
```

2. [最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

双指针之快慢指针，注意fast <= nums.length，有可能最长连续在结尾。eg: [1,1,0,1,1,1]

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxConsecutiveOnes = function(nums) {
    let maxLen = 0, slow = 0
    for (let fast = 0; fast <= nums.length; fast ++) {
        if (nums[fast] != 1) {
            maxLen = Math.max(maxLen, fast - slow)
            slow = fast + 1
        }
    }
    return maxLen
};
```

方法二：一次遍历，记录maxLen，同样注意，有可能最长连续在结尾。eg: [1,1,0,1,1,1]。

```
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxConsecutiveOnes = function(nums) {
    let maxLen = 0, count = 0
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] != 1) {
            maxLen = Math.max(maxLen, count)
            count = 0
        } else {
            count++
        }
    }
    maxLen = Math.max(maxLen, count)
    return maxLen
};
```

3. [长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

暴力法

```
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(target, nums) {
    let min = Number.MAX_SAFE_INTEGER
    for (let i = 0; i < nums.length; i++) {
        let count = 0
        for (let j = i; j < nums.length; j++) {
            if (count + nums[j] >= target) {
                min = Math.min(min, j - i + 1)
                break
            } else {
                count += nums[j]
            }
        }
    }
    return min == Number.MAX_SAFE_INTEGER ? 0 : min
};
```

快慢指针之滑动窗口

每一次外层迭代，都将 nums[end] 假如到sum中，当sum >= target，更新子数组的最小长度。

同时，start指针右移，sum减去nums[start]，直到sum < s，这个过程，也更新子数组的最小长度。

每一次迭代后，end指针后移。

```
/**
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function(target, nums) {
    let start = 0, end = 0, ans = Number.MAX_SAFE_INTEGER, sum = 0, n = nums.length
    while (end < n) {
        sum += nums[end]
        while (sum >= target) {
            ans = Math.min(ans, end - start + 1)
            sum -= nums[start]
            start++
        }
        end++
    }
    return ans == Number.MAX_SAFE_INTEGER ? 0 : ans
};
```